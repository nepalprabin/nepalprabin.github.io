{
  "hash": "d5729f09c4f880fb6cc2c1fd55ca60c6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ncategories:\n  - llms \n  - agents\ndate: \"2025-03-02\"\nimage: /images/leetcode.png\nmainfont: serif\ntitle: 'Huggingface AI Agents Quiz Solutions'\nformat:\n  html:\n    code-fold: true\njupyter: python3\ndraft: false\n---\n\n\nI have been diving into AI agents through Huggingface's AI Agents Course. This course offers a comprehensive understanding of how to build and deploy AI agents using the ```smolagents``` library. In this blog, I'll share insights from the course (Unit 2) and provide code snippets to illustrate key concepts. \n\n:::{.callout-note}\nHere is the course link if anyone is interested. [AI Agents Course\n](https://huggingface.co/learn/agents-course/unit0/introduction)\n:::\n\n## Create a Basic Code Agent with Web Search Capability\nOne of the foundational exercises involves creating a CodeAgent equipped with web search capabilities. This agent leverages the DuckDuckGoSearchTool to perform web searches, enabling it to fetch real-time information. Here's how you can set it up:\n```{{python}}\n    # Create a CodeAgent with DuckDuckGo search capability\n    from smolagents import CodeAgent, DuckDuckGoSearchTool, HfApiModel\n\n    agent = CodeAgent(\n        tools=[DuckDuckGoSearchTool()],           # Add search tool here\n        model=HfApiModel(\"Qwen/Qwen2.5-Coder-32B-Instruct\")          # Add model here\n    )\n```\nIn this snippet, we initialize a CodeAgent with the DuckDuckGoSearchTool, allowing the agent to perform web searches to answer queries.\n\n## Set Up a Multi-Agent System with Manager and Web Search Agents\nMulti-Agent systems are the agents that are specialized on complex tasks with more scalable and robust nature. In ```smolagents```, various agents can be integrated to produce Python code, invoke external tools, conduct web searches, and more. By coordinating these agents, it's possible to develop robust workflows. A typical multi-agent system includes:\n\n        - A manager Agent\n        - A code interpreter Agent\n        - A web Search Agent\nMulti-agent system allows to separate memories between different sub-tasks and provide great benefits. Firstly, each agent are more focused on its core taks and secondly, separating memories reduces the count of input tokens resulting in reducing latency and cost. Below is the multi-agent system when ```web_agent``` performs search and ```manager_agent``` gives data analysis capabilities. Also, we can import dependencies (like python libraries) that helps to perform the tasks.\n```python\n    from smolagents import CodeAgent, ToolCallingAgent, DuckDuckGoSearchTool, HfApiModel, VisitWebpageTool\n\n    web_agent = ToolCallingAgent(\n        tools=[DuckDuckGoSearchTool(), VisitWebpageTool()], \n        model=HfApiModel(model_id=\"Qwen/Qwen2.5-Coder-32B-Instruct\"),\n        max_steps=10,\n        name=\"search\", \n        description=\"Agent to perform web searches and visit webpages.\"\n    )\n\n\n    manager_agent = CodeAgent(\n        model=HfApiModel(model_id=\"Qwen/Qwen2.5-Coder-32B-Instruct\"),\n        managed_agents=[web_agent],\n        additional_authorized_imports=[\"pandas\", \"time\", \"numpy\"] # Corrected imports\n    )\n```\n\n## Configure Agent Security Settings\nSecurity is a crucial aspect when deploying AI agents, especially when they execute code. Below code snippet uses E2B to run code in a sandboxed environment. It is a remote execution that run the code in a isolated container.\n```python\n    from smolagents import CodeAgent, HfApiModel\n    from smolagents.sandbox import E2BSandbox\n\n    model = HfApiModel(\"Qwen/Qwen2.5-Coder-32B-Instruct\")\n\n    agent = CodeAgent(\n        tools=[],\n        model=model,\n        sandbox=E2BSandbox(),  # Configure the sandbox\n        additional_authorized_imports=[\"numpy\"],  # Authorize numpy import\n    )\n```\n\n## Implement a Tool-Calling Agent\nSimilar to ```CodeAgent```, ```ToolCallingAgent``` is another type of agent available in smolagent library. CodeAgent uses Python code snippets whereas ToolCallingAgent use built-in tool-calling capabilities of LLM providers and generate JSON structures.\n```python\n    from smolagents import ToolCallingAgent, HfApiModel, DuckDuckGoSearchTool\n\n    agent = ToolCallingAgent(\n        tools=[DuckDuckGoSearchTool()],  \n        model=HfApiModel(model_id=\"Qwen/Qwen2.5-Coder-32B-Instruct\"),  \n        name=\"SearchAgent\",  \n        description=\"An agent that uses DuckDuckGo to search the web.\",  \n        max_steps=5,  \n    )\n```\n\n## Set Up Model Integration\nLLM models are the most important aspect when creating AI agents. There are many model availables for various tasks and domains. So we can easily integrate models that is required for our task. Below code snippet switches between two different models providers.\n```python\n    from smolagents import HfApiModel, LiteLLMModel\n\n    # Initialize Hugging Face model\n    hf_model = HfApiModel(model_id=\"Qwen/Qwen2.5-Coder-32B-Instruct\")\n\n    # Initialize LiteLLM model as an alternative model\n    other_model = LiteLLMModel(model_id=\"anthropic/claude-3-sonnet\")\n\n    # Set the model to hf_model or alternative model\n    model = hf_model  # Alternatively, you can switch this to `other_model`\n```\n\n",
    "supporting": [
      "2025-03-02-huggingface-smolagents-solutions_files"
    ],
    "filters": [],
    "includes": {}
  }
}